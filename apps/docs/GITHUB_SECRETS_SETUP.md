# GitHub Secrets Configuration Guide

This document outlines all GitHub Secrets required for the CI/CD pipeline to function properly.

## Required GitHub Secrets

Navigate to: **Repository → Settings → Secrets and variables → Actions → New repository secret**

### 1. Azure Authentication

#### AZURE_CREDENTIALS
**Purpose**: Authenticate GitHub Actions with Azure for deployments

**How to get**:
```bash
# Create a service principal with contributor role
az ad sp create-for-rbac \
  --name "SaudiStore-GitHub-Actions" \
  --role contributor \
  --scopes /subscriptions/{subscription-id}/resourceGroups/{resource-group} \
  --sdk-auth
```

**Value format** (JSON):
```json
{
  "clientId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "clientSecret": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
  "subscriptionId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "tenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
}
```

---

### 2. Azure Container Registry (ACR)

#### AZURE_CONTAINER_REGISTRY
**Purpose**: Docker image registry URL

**How to get**:
```bash
az acr list --query "[].{name:name, loginServer:loginServer}" -o table
```

**Value**: `Saudi Store.azurecr.io` (your ACR login server)

#### AZURE_CONTAINER_REGISTRY_USERNAME
**Purpose**: ACR authentication username

**How to get**:
```bash
az acr credential show --name Saudi Store --query "username" -o tsv
```

**Value**: Usually same as ACR name: `Saudi Store`

#### AZURE_CONTAINER_REGISTRY_PASSWORD
**Purpose**: ACR authentication password

**How to get**:
```bash
az acr credential show --name Saudi Store --query "passwords[0].value" -o tsv
```

**Value**: Long alphanumeric string (keep secure!)

---

### 3. Code Quality & Testing

#### CODECOV_TOKEN
**Purpose**: Upload test coverage reports to Codecov

**How to get**:
1. Go to [codecov.io](https://codecov.io)
2. Sign in with GitHub
3. Add your repository
4. Copy the upload token

**Value**: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`

---

### 4. Notifications

#### SLACK_WEBHOOK
**Purpose**: Send deployment notifications to Slack

**How to get**:
1. Go to your Slack workspace
2. Navigate to: Apps → Incoming Webhooks
3. Click "Add to Slack"
4. Choose channel (e.g., #deployments)
5. Copy the webhook URL

**Value**: `https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX`

---

### 5. Database Connections

#### DATABASE_URL_STAGING
**Purpose**: PostgreSQL connection string for staging environment

**Format**:
```
postgresql://username:password@hostname:5432/database?sslmode=require
```

**Example**:
```
postgresql://saudistore_admin:SecurePass123!@saudistore-staging-db.postgres.database.azure.com:5432/Saudi Store_staging?sslmode=require
```

**How to get**:
```bash
# Get connection string from Azure
az postgres server show-connection-string \
  --server-name saudistore-staging-db \
  --admin-user saudistore_admin \
  --admin-password <your-password>
```

#### DATABASE_URL_PRODUCTION
**Purpose**: PostgreSQL connection string for production environment

**Format**: Same as staging (different server/database)

**Example**:
```
postgresql://saudistore_admin:SecurePass123!@saudistore-prod-db.postgres.database.azure.com:5432/Saudi Store_prod?sslmode=require
```

---

### 6. Application Secrets (from .env.secrets)

These secrets were generated by `node scripts/generate-secrets.js`

#### JWT_SECRET
**Purpose**: JWT token signing

**Value**: Copy from `.env.secrets` file

#### NEXTAUTH_SECRET
**Purpose**: NextAuth session encryption

**Value**: Copy from `.env.secrets` file

#### ENCRYPTION_KEY
**Purpose**: Data encryption at rest

**Value**: Copy from `.env.secrets` file

#### SESSION_SECRET
**Purpose**: Session encryption

**Value**: Copy from `.env.secrets` file

#### WEBHOOK_SECRET
**Purpose**: Webhook signature verification

**Value**: Copy from `.env.secrets` file

#### API_KEY_SALT
**Purpose**: API key hashing salt

**Value**: Copy from `.env.secrets` file

---

### 7. Monitoring & Observability

#### NEXT_PUBLIC_APPLICATIONINSIGHTS_CONNECTION_STRING
**Purpose**: Azure Application Insights telemetry

**How to get**:
```bash
# Get from Azure Application Insights
az monitor app-insights component show \
  --app saudistore-appinsights \
  --resource-group saudistoreProd \
  --query "connectionString" -o tsv
```

**Value**: `InstrumentationKey=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx;IngestionEndpoint=https://...`

#### SENTRY_DSN
**Purpose**: Sentry error tracking

**How to get**:
1. Go to [sentry.io](https://sentry.io)
2. Create a new project (or select existing)
3. Navigate to: Settings → Projects → [Your Project] → Client Keys (DSN)
4. Copy the DSN

**Value**: `https://xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx@o000000.ingest.sentry.io/0000000`

#### NEXT_PUBLIC_SENTRY_DSN
**Purpose**: Sentry error tracking (client-side)

**Value**: Same as SENTRY_DSN (duplicated for client/server)

---

### 8. Additional Configuration (Optional)

#### REDIS_URL_STAGING
**Purpose**: Redis cache connection for staging

**Format**: `redis://[:password@]hostname:6379/0`

**Example**: `redis://:password@saudistore-staging-redis.redis.cache.windows.net:6380?ssl=true`

#### REDIS_URL_PRODUCTION
**Purpose**: Redis cache connection for production

**Format**: Same as staging (different server)

#### STRIPE_SECRET_KEY
**Purpose**: Stripe payment processing

**How to get**:
1. Go to [dashboard.stripe.com](https://dashboard.stripe.com)
2. Navigate to: Developers → API keys
3. Copy the "Secret key" (starts with `sk_`)

**Value**: `sk_live_...` or `sk_test_...`

#### STRIPE_WEBHOOK_SECRET
**Purpose**: Stripe webhook signature verification

**How to get**:
1. Go to Stripe Dashboard → Developers → Webhooks
2. Click on your webhook endpoint
3. Copy the "Signing secret"

**Value**: `whsec_...`

---

## Configuration Steps

### Step 1: Add Secrets to GitHub

1. Navigate to your repository on GitHub
2. Click **Settings** → **Secrets and variables** → **Actions**
3. Click **New repository secret**
4. Add each secret from the list above
5. Verify all secrets are added (should see 15+ secrets)

### Step 2: Create GitHub Environments

1. Navigate to **Settings** → **Environments**
2. Create two environments:
   - **staging**
   - **production**

3. For **production** environment:
   - Enable **Required reviewers** (at least 1 reviewer)
   - Set **Wait timer**: 0 minutes (or as needed)
   - Add **Deployment branches**: Only `main` branch

4. For **staging** environment:
   - No additional protection needed
   - Deployment branches: `develop` and `main`

### Step 3: Configure Branch Protection

1. Navigate to **Settings** → **Branches** → **Add branch protection rule**

2. For `main` branch:
   - Branch name pattern: `main`
   - ✅ Require a pull request before merging
   - ✅ Require approvals: 1
   - ✅ Require status checks to pass before merging
   - ✅ Require branches to be up to date before merging
   - Status checks: `code-quality`, `test`, `build`
   - ✅ Require conversation resolution before merging
   - ✅ Do not allow bypassing the above settings

3. For `develop` branch:
   - Branch name pattern: `develop`
   - ✅ Require a pull request before merging
   - ✅ Require status checks to pass before merging
   - Status checks: `code-quality`, `test`

### Step 4: Test the Pipeline

1. Create a test branch:
   ```bash
   git checkout -b test/ci-cd-setup
   ```

2. Make a small change and commit:
   ```bash
   echo "# CI/CD Test" >> README.md
   git add README.md
   git commit -m "test: CI/CD pipeline setup"
   git push origin test/ci-cd-setup
   ```

3. Create a Pull Request to `develop`

4. Verify GitHub Actions run:
   - Code quality check ✅
   - Tests ✅
   - Build ✅

5. Merge PR and verify deployment to staging

### Step 5: Verify Deployments

**Staging Deployment**:
- Triggered on push to `develop`
- Check GitHub Actions logs
- Verify health endpoint: `https://saudistore-staging.azurecontainerapps.io/api/health`

**Production Deployment**:
- Triggered on push to `main`
- Requires manual approval (if configured)
- Check GitHub Actions logs
- Verify health endpoint: `https://saudistore.azurecontainerapps.io/api/health`

---

## Security Best Practices

### ✅ Do:
- Use Azure Key Vault for production secrets
- Rotate secrets every 90 days
- Use different secrets for each environment
- Enable GitHub secret scanning
- Review audit logs regularly
- Use least-privilege access for service principals

### ❌ Don't:
- Commit secrets to version control
- Share secrets in Slack/email
- Use the same secrets across environments
- Store secrets in plain text files
- Give unnecessary access to GitHub secrets

---

## Troubleshooting

### Pipeline fails with "Azure authentication failed"
**Solution**: Verify `AZURE_CREDENTIALS` is valid JSON and has correct permissions

### Docker push fails
**Solution**: Check ACR credentials (`AZURE_CONTAINER_REGISTRY_*` secrets)

### Database migration fails
**Solution**: Verify `DATABASE_URL_*` is correct and accessible from GitHub Actions

### No Slack notifications
**Solution**: Check `SLACK_WEBHOOK` URL is valid and channel exists

### Codecov upload fails
**Solution**: Verify `CODECOV_TOKEN` is correct for your repository

---

## Quick Reference Checklist

- [ ] AZURE_CREDENTIALS (Azure service principal)
- [ ] AZURE_CONTAINER_REGISTRY (ACR login server)
- [ ] AZURE_CONTAINER_REGISTRY_USERNAME (ACR username)
- [ ] AZURE_CONTAINER_REGISTRY_PASSWORD (ACR password)
- [ ] CODECOV_TOKEN (Codecov upload token)
- [ ] SLACK_WEBHOOK (Slack webhook URL)
- [ ] DATABASE_URL_STAGING (Staging DB connection)
- [ ] DATABASE_URL_PRODUCTION (Production DB connection)
- [ ] JWT_SECRET (JWT signing key)
- [ ] NEXTAUTH_SECRET (NextAuth encryption)
- [ ] ENCRYPTION_KEY (Data encryption)
- [ ] SESSION_SECRET (Session encryption)
- [ ] WEBHOOK_SECRET (Webhook verification)
- [ ] API_KEY_SALT (API key hashing)
- [ ] NEXT_PUBLIC_APPLICATIONINSIGHTS_CONNECTION_STRING (App Insights)
- [ ] SENTRY_DSN (Sentry error tracking)
- [ ] NEXT_PUBLIC_SENTRY_DSN (Sentry client-side)

**Total Required**: 17 secrets minimum

---

**Last Updated**: November 12, 2025
**Document Version**: 1.0

