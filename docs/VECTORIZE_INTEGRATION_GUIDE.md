# ğŸ” Ø¯Ù„ÙŠÙ„ ØªÙƒØ§Ù…Ù„ Cloudflare Vectorize - Vector Database Integration

## **Ø§Ù„Ù…ØªØ¬Ø± Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠ - Saudi Store**

### **Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ¬Ù‡Ø© Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ ÙˆØ§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ**

---

## **ğŸ“‹ Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©**

Cloudflare Vectorize Ù‡ÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ù…ØªØ¬Ù‡Ø© (Vector Database) ØªØªÙŠØ­:

- Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø¯Ù„Ø§Ù„ÙŠ (Semantic Search)
- Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø°ÙƒÙŠØ©
- Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„ØªØ´Ø§Ø¨Ù‡
- ØªÙƒØ§Ù…Ù„ Ù…Ø¹ AI/ML Models

---

## **ğŸ¯ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙŠ Ø§Ù„Ù…ØªØ¬Ø± Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠ**

### **1. Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ ÙÙŠ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª**

```typescript
// Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ù†ØªØ¬Ø§Øª Ù…Ø´Ø§Ø¨Ù‡Ø©
"Ø£Ø±ÙŠØ¯ Ù…Ù†ØªØ¬ Ù…Ø«Ù„ Ù‡Ø°Ø§" â†’ Vector Search â†’ Ù†ØªØ§Ø¦Ø¬ Ù…Ø´Ø§Ø¨Ù‡Ø©
```

### **2. Ø§Ù„ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø´Ø®ØµÙŠØ©**

```typescript
// ØªÙˆØµÙŠØ§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø³Ù„ÙˆÙƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
Ø³Ø¬Ù„ Ø§Ù„Ù…Ø´ØªØ±ÙŠØ§Øª â†’ Vectors â†’ Ù…Ù†ØªØ¬Ø§Øª Ù…ÙˆØµÙ‰ Ø¨Ù‡Ø§
```

### **3. Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª**

```typescript
// Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„ÙÙˆØ§ØªÙŠØ± ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±
"Ø£ÙŠÙ† ÙØ§ØªÙˆØ±Ø© Ø´Ù‡Ø± ÙŠÙ†Ø§ÙŠØ±ØŸ" â†’ Vector Search â†’ Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø°Ø§Øª Ø§Ù„ØµÙ„Ø©
```

### **4. Ø¯Ø¹Ù… Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ø°ÙƒÙŠ**

```typescript
// Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©
"ÙƒÙŠÙ Ø£Ø³Ø¬Ù„ Ù…Ø¹Ø§Ù…Ù„Ø©ØŸ" â†’ Vector Search â†’ Ù…Ù‚Ø§Ù„Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
```

---

## **ğŸš€ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ù„ØªÙƒØ§Ù…Ù„**

### **Ø§Ù„Ø®Ø·ÙˆØ© 1: Ø¥Ù†Ø´Ø§Ø¡ Vectorize Index**

```bash
# Ø¥Ù†Ø´Ø§Ø¡ index Ø¬Ø¯ÙŠØ¯
npx wrangler vectorize create saudi-store-products \
  --dimensions=1536 \
  --metric=cosine

# Ø¥Ù†Ø´Ø§Ø¡ index Ù„Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª
npx wrangler vectorize create saudi-store-documents \
  --dimensions=1536 \
  --metric=cosine

# Ø¥Ù†Ø´Ø§Ø¡ index Ù„Ù„Ø¯Ø¹Ù…
npx wrangler vectorize create saudi-store-support \
  --dimensions=768 \
  --metric=euclidean
```

---

### **Ø§Ù„Ø®Ø·ÙˆØ© 2: ØªÙƒÙˆÙŠÙ† Wrangler**

**Ù…Ù„Ù:** `wrangler.toml`

```toml
name = "saudi-store-api"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[[vectorize]]
binding = "VECTORIZE_PRODUCTS"
index_name = "saudi-store-products"

[[vectorize]]
binding = "VECTORIZE_DOCUMENTS"
index_name = "saudi-store-documents"

[[vectorize]]
binding = "VECTORIZE_SUPPORT"
index_name = "saudi-store-support"
```

---

### **Ø§Ù„Ø®Ø·ÙˆØ© 3: Ø¥Ù†Ø´Ø§Ø¡ Metadata Indexes**

```bash
# Products - ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©
npx wrangler vectorize create-metadata-index saudi-store-products \
  --property-name=category \
  --type=string

# Products - ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø³Ø¹Ø±
npx wrangler vectorize create-metadata-index saudi-store-products \
  --property-name=price \
  --type=number

# Products - ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ØªÙˆÙØ±
npx wrangler vectorize create-metadata-index saudi-store-products \
  --property-name=inStock \
  --type=boolean

# Documents - ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
npx wrangler vectorize create-metadata-index saudi-store-documents \
  --property-name=documentType \
  --type=string

# Documents - ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
npx wrangler vectorize create-metadata-index saudi-store-documents \
  --property-name=createdAt \
  --type=number
```

---

## **ğŸ’» Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙÙŠ Next.js**

### **Ø§Ù„Ù…Ù„Ù:** `lib/services/vectorize.service.ts`

```typescript
import { Vectorize } from '@cloudflare/workers-types';

export interface VectorizeEnv {
  VECTORIZE_PRODUCTS: Vectorize;
  VECTORIZE_DOCUMENTS: Vectorize;
  VECTORIZE_SUPPORT: Vectorize;
}

// Product Vector
export interface ProductVector {
  id: string;
  productId: string;
  productName: string;
  productNameAr: string;
  description: string;
  descriptionAr: string;
  category: string;
  price: number;
  inStock: boolean;
  embedding: number[]; // 1536 dimensions from OpenAI
}

// Document Vector
export interface DocumentVector {
  id: string;
  documentId: string;
  documentType: 'invoice' | 'report' | 'contract' | 'receipt';
  title: string;
  titleAr: string;
  content: string;
  contentAr: string;
  createdAt: number;
  tenantId: string;
  embedding: number[];
}

// Support Vector
export interface SupportVector {
  id: string;
  articleId: string;
  question: string;
  questionAr: string;
  answer: string;
  answerAr: string;
  category: string;
  embedding: number[];
}

export class VectorizeService {
  
  // Insert Product Vectors
  static async insertProducts(
    env: VectorizeEnv,
    products: ProductVector[]
  ) {
    const vectors = products.map(p => ({
      id: p.id,
      values: p.embedding,
      metadata: {
        productId: p.productId,
        productName: p.productName,
        productNameAr: p.productNameAr,
        category: p.category,
        price: p.price,
        inStock: p.inStock
      }
    }));
    
    const result = await env.VECTORIZE_PRODUCTS.insert(vectors);
    return result;
  }
  
  // Search Products
  static async searchProducts(
    env: VectorizeEnv,
    queryEmbedding: number[],
    options?: {
      topK?: number;
      filter?: string;
      returnValues?: boolean;
    }
  ) {
    const matches = await env.VECTORIZE_PRODUCTS.query(queryEmbedding, {
      topK: options?.topK || 10,
      filter: options?.filter,
      returnValues: options?.returnValues || false,
      returnMetadata: 'all'
    });
    
    return matches;
  }
  
  // Search with Filters
  static async searchProductsByCategory(
    env: VectorizeEnv,
    queryEmbedding: number[],
    category: string,
    minPrice?: number,
    maxPrice?: number
  ) {
    let filter = `category = "${category}"`;
    
    if (minPrice !== undefined) {
      filter += ` AND price >= ${minPrice}`;
    }
    
    if (maxPrice !== undefined) {
      filter += ` AND price <= ${maxPrice}`;
    }
    
    return await this.searchProducts(env, queryEmbedding, {
      topK: 20,
      filter
    });
  }
  
  // Insert Documents
  static async insertDocuments(
    env: VectorizeEnv,
    documents: DocumentVector[]
  ) {
    const vectors = documents.map(d => ({
      id: d.id,
      values: d.embedding,
      metadata: {
        documentId: d.documentId,
        documentType: d.documentType,
        title: d.title,
        titleAr: d.titleAr,
        createdAt: d.createdAt,
        tenantId: d.tenantId
      }
    }));
    
    const result = await env.VECTORIZE_DOCUMENTS.insert(vectors);
    return result;
  }
  
  // Search Documents
  static async searchDocuments(
    env: VectorizeEnv,
    queryEmbedding: number[],
    tenantId: string,
    documentType?: string
  ) {
    let filter = `tenantId = "${tenantId}"`;
    
    if (documentType) {
      filter += ` AND documentType = "${documentType}"`;
    }
    
    const matches = await env.VECTORIZE_DOCUMENTS.query(queryEmbedding, {
      topK: 10,
      filter,
      returnMetadata: 'all'
    });
    
    return matches;
  }
  
  // Insert Support Articles
  static async insertSupportArticles(
    env: VectorizeEnv,
    articles: SupportVector[]
  ) {
    const vectors = articles.map(a => ({
      id: a.id,
      values: a.embedding,
      metadata: {
        articleId: a.articleId,
        question: a.question,
        questionAr: a.questionAr,
        category: a.category
      }
    }));
    
    const result = await env.VECTORIZE_SUPPORT.insert(vectors);
    return result;
  }
  
  // Search Support
  static async searchSupport(
    env: VectorizeEnv,
    queryEmbedding: number[],
    locale: 'ar' | 'en'
  ) {
    const matches = await env.VECTORIZE_SUPPORT.query(queryEmbedding, {
      topK: 5,
      returnMetadata: 'all'
    });
    
    return matches;
  }
}
```

---

## **ğŸ¤– ØªÙƒØ§Ù…Ù„ Ù…Ø¹ OpenAI Ù„Ù„Ù€ Embeddings**

### **Ø§Ù„Ù…Ù„Ù:** `lib/services/embeddings.service.ts`

```typescript
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

export class EmbeddingsService {
  
  // Generate embedding for text
  static async generateEmbedding(text: string): Promise<number[]> {
    const response = await openai.embeddings.create({
      model: 'text-embedding-3-small', // 1536 dimensions
      input: text
    });
    
    return response.data[0].embedding;
  }
  
  // Generate embeddings for multiple texts
  static async generateEmbeddings(texts: string[]): Promise<number[][]> {
    const response = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: texts
    });
    
    return response.data.map(d => d.embedding);
  }
  
  // Generate embedding for product
  static async generateProductEmbedding(product: {
    name: string;
    nameAr: string;
    description: string;
    descriptionAr: string;
    category: string;
  }): Promise<number[]> {
    // Combine all text fields
    const text = `${product.name} ${product.nameAr} ${product.description} ${product.descriptionAr} ${product.category}`;
    return await this.generateEmbedding(text);
  }
  
  // Generate embedding for document
  static async generateDocumentEmbedding(document: {
    title: string;
    titleAr: string;
    content: string;
    contentAr: string;
  }): Promise<number[]> {
    const text = `${document.title} ${document.titleAr} ${document.content.substring(0, 1000)} ${document.contentAr.substring(0, 1000)}`;
    return await this.generateEmbedding(text);
  }
}
```

---

## **ğŸ“¡ API Endpoints**

### **Ø§Ù„Ù…Ù„Ù:** `app/api/search/products/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { EmbeddingsService } from '@/lib/services/embeddings.service';
import { VectorizeService } from '@/lib/services/vectorize.service';

export async function POST(req: NextRequest) {
  try {
    const { query, category, minPrice, maxPrice, locale } = await req.json();
    
    // Generate embedding for search query
    const queryEmbedding = await EmbeddingsService.generateEmbedding(query);
    
    // Search in Vectorize
    const matches = await VectorizeService.searchProductsByCategory(
      env, // Ù…Ù† Cloudflare Workers
      queryEmbedding,
      category,
      minPrice,
      maxPrice
    );
    
    // Get full product details from database
    const productIds = matches.matches.map(m => m.metadata.productId);
    const products = await getProductsByIds(productIds);
    
    return NextResponse.json({
      success: true,
      query,
      matches: matches.matches.map((match, index) => ({
        product: products[index],
        score: match.score,
        metadata: match.metadata
      }))
    });
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}
```

### **Ø§Ù„Ù…Ù„Ù:** `app/api/search/documents/route.ts`

```typescript
export async function POST(req: NextRequest) {
  try {
    const { query, tenantId, documentType, locale } = await req.json();
    
    // Generate embedding
    const queryEmbedding = await EmbeddingsService.generateEmbedding(query);
    
    // Search documents
    const matches = await VectorizeService.searchDocuments(
      env,
      queryEmbedding,
      tenantId,
      documentType
    );
    
    return NextResponse.json({
      success: true,
      matches: matches.matches
    });
  } catch (error: any) {
    return NextResponse.json(
      { error: error.message },
      { status: 500 }
    );
  }
}
```

---

## **ğŸ”„ Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Vectorize**

### **Ø§Ù„Ù…Ù„Ù:** `scripts/sync-to-vectorize.ts`

```typescript
import { query } from '../lib/db/connection';
import { EmbeddingsService } from '../lib/services/embeddings.service';
import { VectorizeService } from '../lib/services/vectorize.service';

async function syncProducts() {
  console.log('ğŸ”„ Syncing products to Vectorize...');
  
  // Get all products from database
  const result = await query(`
    SELECT 
      id,
      product_name,
      product_name_ar,
      description,
      description_ar,
      category,
      price,
      in_stock
    FROM products
    WHERE status = 'active'
  `);
  
  const products = result.rows;
  
  // Generate embeddings in batches
  const batchSize = 100;
  for (let i = 0; i < products.length; i += batchSize) {
    const batch = products.slice(i, i + batchSize);
    
    // Generate embeddings
    const embeddings = await Promise.all(
      batch.map(p => EmbeddingsService.generateProductEmbedding({
        name: p.product_name,
        nameAr: p.product_name_ar,
        description: p.description,
        descriptionAr: p.description_ar,
        category: p.category
      }))
    );
    
    // Prepare vectors
    const vectors = batch.map((p, index) => ({
      id: p.id,
      productId: p.id,
      productName: p.product_name,
      productNameAr: p.product_name_ar,
      description: p.description,
      descriptionAr: p.description_ar,
      category: p.category,
      price: p.price,
      inStock: p.in_stock,
      embedding: embeddings[index]
    }));
    
    // Insert to Vectorize
    await VectorizeService.insertProducts(env, vectors);
    
    console.log(`âœ… Synced ${i + batch.length}/${products.length} products`);
  }
  
  console.log('âœ… Products sync completed!');
}

async function syncDocuments() {
  console.log('ğŸ”„ Syncing documents to Vectorize...');
  
  const result = await query(`
    SELECT 
      id,
      document_type,
      title,
      title_ar,
      content,
      content_ar,
      tenant_id,
      created_at
    FROM documents
    WHERE status = 'active'
  `);
  
  const documents = result.rows;
  
  // Similar process as products...
  
  console.log('âœ… Documents sync completed!');
}

// Run sync
syncProducts()
  .then(() => syncDocuments())
  .then(() => {
    console.log('ğŸ‰ All data synced to Vectorize!');
    process.exit(0);
  })
  .catch(error => {
    console.error('âŒ Sync failed:', error);
    process.exit(1);
  });
```

---

## **ğŸ¨ UI Component Ù„Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ**

### **Ø§Ù„Ù…Ù„Ù:** `components/SmartSearch.tsx`

```typescript
"use client";
import { useState } from 'react';
import { Search, Loader2 } from 'lucide-react';

export default function SmartSearch() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const handleSearch = async () => {
    if (!query.trim()) return;
    
    setLoading(true);
    try {
      const response = await fetch('/api/search/products', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query })
      });
      
      const data = await response.json();
      setResults(data.matches);
    } catch (error) {
      console.error('Search failed:', error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="w-full max-w-4xl mx-auto">
      <div className="relative">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
          placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø£ÙŠ Ø´ÙŠØ¡..."
          className="w-full px-4 py-3 pr-12 rounded-xl border"
        />
        <button
          onClick={handleSearch}
          disabled={loading}
          className="absolute right-3 top-1/2 -translate-y-1/2"
        >
          {loading ? (
            <Loader2 className="h-5 w-5 animate-spin" />
          ) : (
            <Search className="h-5 w-5" />
          )}
        </button>
      </div>
      
      {results.length > 0 && (
        <div className="mt-4 space-y-2">
          {results.map((result, index) => (
            <div key={index} className="p-4 rounded-xl border">
              <h3 className="font-semibold">{result.product.name}</h3>
              <p className="text-sm text-neutral-600">{result.product.description}</p>
              <div className="mt-2 flex items-center gap-2">
                <span className="text-sm font-medium">{result.product.price} Ø±ÙŠØ§Ù„</span>
                <span className="text-xs text-neutral-500">
                  ØªØ·Ø§Ø¨Ù‚: {(result.score * 100).toFixed(1)}%
                </span>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

---

## **âœ… Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ­Ù‚Ù‚**

- [ ] Ø­Ø³Ø§Ø¨ Cloudflare Ù…ÙØ¹Ù„
- [ ] Wrangler CLI Ù…Ø«Ø¨Øª
- [ ] Vectorize indexes Ù…Ù†Ø´Ø£Ø© (3 indexes)
- [ ] Metadata indexes Ù…ÙƒÙˆÙ†Ø©
- [ ] OpenAI API key Ù…ÙˆØ¬ÙˆØ¯
- [ ] Embeddings service Ø¬Ø§Ù‡Ø²
- [ ] Vectorize service Ø¬Ø§Ù‡Ø²
- [ ] API endpoints Ù…Ù†Ø´Ø£Ø©
- [ ] UI components Ø¬Ø§Ù‡Ø²Ø©
- [ ] Sync script Ø¬Ø§Ù‡Ø²
- [ ] Ø¨ÙŠØ§Ù†Ø§Øª ØªÙ… Ù…Ø²Ø§Ù…Ù†ØªÙ‡Ø§

---

**ğŸ‰ Vectorize Integration Ø¬Ø§Ù‡Ø²!**

**Ø§Ù„Ù…ÙŠØ²Ø§Øª:**
âœ… Ø¨Ø­Ø« Ø¯Ù„Ø§Ù„ÙŠ Ø°ÙƒÙŠ  
âœ… ØªÙˆØµÙŠØ§Øª Ø´Ø®ØµÙŠØ©  
âœ… Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª  
âœ… Ø¯Ø¹Ù… Ø¹Ù…Ù„Ø§Ø¡ Ø°ÙƒÙŠ  
âœ… ØªÙƒØ§Ù…Ù„ OpenAI  
âœ… Multi-index support  
âœ… Metadata filtering  
âœ… Real-time sync  

**ğŸš€ Ø§Ù„Ù…ØªØ¬Ø± Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠ - Saudi Store**
